platform :ios, '9.0'

if File.exists?('Podfile.lock')
  puts "\033[33mPodfile.lock removed\033[0m"
  `rm Podfile.lock`
end

use_frameworks!
inhibit_all_warnings!
use_modular_headers!

install! 'cocoapods',
  :generate_multiple_pod_projects => true,
  :incremental_installation => true

target 'BeSwifter_Example' do
  pod 'BeSwifter', :path => '../BeSwifter'
  pod 'SnapKit'
  pod 'SwifterSwift'
  pod 'MLeaksFinder'
  pod 'Starscream'
  pod 'SwiftyJSON'
  pod 'CocoaLumberjack/Swift'
  pod 'Peregrine', :modular_headers => true
  pod 'MLeaksFinder', :configurations => ['Debug']
  
  pod 'PureObjCLib', :path =>  '../../PureObjCLib', :modular_headers => true
  pod 'PureSwiftLib', :path => '../../PureSwiftLib'
  pod 'HybridLib', :path => '../../HybridLib'
  pod 'SwiftPodLib', :path => '../../SwiftPodLib'

  target 'BeSwifter_Tests' do
    inherit! :search_paths

    pod 'Quick', '~> 2.2.0'
    pod 'Nimble', '~> 8.0.7'
  end
end

post_install do |installer|
  # 添加编译脚本，每次编译时都会重新收集路由表
  require_relative '../../../../Peregrine/Peregrine/PGGenerator.rb'
  PGGenerator::configure_project(installer, {'expr' => true, 'name' => 'PGRouteDefine', 'path' => '${SRCROOT}/Peregrine'})
    
    # workaround for https://github.com/CocoaPods/CocoaPods/issues/3289
    Pod::Installer::Xcode::TargetValidator.send(:define_method, :verify_no_static_framework_transitive_dependencies) {}
  
  # 解决混编Pod使用CocoaLumberjack的问题(需要使用动态库方式)
  installer.pods_project&.targets&.each do |target|
    compatibilityPhase = target.build_phases.find { |ph| ph.display_name == 'Copy generated compatibility header' }
    if compatibilityPhase
      build_phase = target.new_shell_script_build_phase('Copy Swift Header')
      build_phase.shell_script = <<-SH.strip_heredoc
      COMPATIBILITY_HEADER_PATH="${BUILT_PRODUCTS_DIR}/Swift Compatibility Header/${PRODUCT_MODULE_NAME}-Swift.h"
      ditto "${COMPATIBILITY_HEADER_PATH}" "${PODS_ROOT}/Headers/Public/${PRODUCT_MODULE_NAME}/${PRODUCT_MODULE_NAME}-Swift.h"
      SH
    end
  end
    
end
